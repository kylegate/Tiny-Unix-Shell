# Tiny-Unix-Shell
 
Design Overview:
My shell.c program implemented chars and arrays of chars to manage input. I used a while loop to read the input until either exit condition was met, the shell command "quit", the user type ctrl-d, or the end of file was reached without the quit command. The meat of the while loop was parsing the input. Each line was first put into an array after it was parsed using “;” as the delimiter, making use of the strtok_r() function, which I preferred as I had greater control over where return value using a pointer. Once the entire line of input was stored into the char array which I called commands[], they were then trimmed of any leading or trailing whitespaces so it would be easier to check for the quit command. I then created an inner loop that would parse each command yet again using strtok_r() and tokenize them based on whitespace. Once the command and its arguments were tokenized, they are executed using my ExecuteCommand function which would create a new fork and child process for each command. Then once all arguments from the command line are executed the loop resumes and the user is prompted for new input.

Complete Specification: 
 
Ambiguities and how I handled them. The first ambiguity was the arguments to the tinyshell which I checked using argc to find how many arguments and respond appropriately I also made sure to open the batch file to make sure it was there and if not I let the user know it wasn't found or couldn't be opened. The second instance was a null or empty command which I had my fget() command compare the input to NULL and if it was NULL the program would prompt/move onto the next line, Instances such as multiple semicolons were easily taken care of by strtok() since the function would search for the delimiter and add a null terminator there so instances where there were multiple strtok would just  add a null terminator at the last semicolon. Those were the big instances of being either null command, empty commands, and multiple semicolons.
